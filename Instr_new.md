# Инструкция по работе в системе контроля версий 
## Первая статья
###  Что такое Git
Git — это набор консольных утилит, которые отслеживают и фиксируют  изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус)
С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению.Этот процесс называется контролем версий.Для чего он нужен? Ну во-первых, чтобы отследить изменения, произошедшие с проектом, со временем.Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать.Во-вторых он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
### Основные команды
   - git init-включает приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.
   - git status -это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее.
   - git add -добавляет(или подготавливает) файлы к коммиту.
   - git commit -m  "<комментарий>"-создает коммит ,а Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. 
   - git log - просмотр всех выполненных фиксаций(история коммитов),добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.
   - git checkout - переключение с ветки на ветку
   - git diff -просмотр списка изменений, внесённых в репозиторий. По умолчанию отображаются только изменения, не подготовленные для фиксации.
   - git diff --staged -просматривать список подготовленных изменений 
### Команды второго семинара
   - git branch <name>  -создает новую ветку, пока что точную копию ветки master.
   - git branch -просмотр наличия веток
   - git checkout branch <name> - переключение на указанную ветку.
   - git checkout commit <name> - переключение на указанную охраненную ветку.
   - git merge - объединение информации на ветках 
   - git show-просмотр полного списока изменений, внесённых конкретным коммитом
   - git mv- переименовать файл или папку Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка.Например:git mv dir1/somefile.js dir2.При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.  
   - git remote -Добавить удалённый репозиторий ; пример написания git remote add awesomeapp https://github.com/someurl..
## Работа с gitignore
   Для того чтобы хранить только исходный код и ничего другого в репозитории надо создать файл в корне проекта с названием **.gitignore**, и в этом файле каждая строка будет шаблоном для игнорирования.Существует несколько способов :

   *ICE.jpeg -это игнорировать только данный файл;
   
   *.jpg - это игнорировать все файлы с данным расширением
   
   */.jpg - это игнорировать все файлы с данным расширением в папке 
  
   Например вставим картинку 
    ![ICE](ICE.jpeg)
    И кинем ее в игнор.


## Ветвление
   Разумеется, работать в одной ветке неудобно одному и невозможно, когда в команде больше одного человека. Для этого существует ветвление.
   Ветка — это просто подвижный указатель на коммиты.Чтобы посмотреть список всех веток в репозитории и понять, на какой находишься, нужно написать:
   
   **git branch -a**
   
   Способ создания ветки  на основе другой. Чтобы создать ветку на основе master ветки,  нужно сначала перейти на нее, а уже следующим шагом — создать новую. 

   Смотрим: 
   
   **git checkout master** — переходим на ветку master;

   **git status** — проверяем, точно ли на мастере;

   **git branch 2308next** - создаем новую ветку с названием 2308next
## ОбЪединение веток
   Есть главная ветка. От нее в какой-то момент создают второстепенную, в которой происходят изменения. Как только работа сделана, нужно слить одну ветку в другую.Для этого нужно перейти в master и написать **git merge 2308next**
   После объединения надо закоммитеть изменения.
## Конфликт слияния
   Предполагается ситуация: есть ветка master и есть ветка 2408next. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку master пытаемся влить ветку 2408next (git merge 2408next), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле instr_new.md.
   При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.
   Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.
   Вот так: git merge --abort
   Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.

Пример: git reset

## Переименование файла
   Переименовать файл или папку можно параметром mv. Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка. 

   Например : git mv dir1/somefile.js dir2  
           
   При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать 
##  Работа с удалённым репозиторием

   Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.
   Пример: git remote add awesomeapp https://github.com/someurl..

  * Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.

      git remote -v

   Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле .git/config репозитория.

   * Получить подробные сведения об удалённом репозитории можно с помощью параметра remote show с указанием имени репозитория — например, origin.

     git remote show origin

Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.

 * Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.

     git push origin main

Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.
 * В удаленном репозитории ветка master называется main, поэтому при добавлении своего локального репозитория  в удаленный надо переименовать ветку master в main.

* Для загрузки изменений из удалённого репозитория используется параметр pull. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.

   git pull

* просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.

  git pull --verbose

* Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.

   git merge origin

* Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.

    git push -u origin new_branch

* Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.

  git push --delete origin existing_branch
# Pull Request — запрос на включение написанного вами кода в чужой репозиторий.#

Для начала этот самый репозиторий нужно форкнуть (fork — вилка, ответвление). Разберём это нехитрое действо на примере веб-сервиса для хостинга IT-проектов, название которому GitHub.Заходим на страницу интересующего проекта, жмём кнопку Fork, ищем на своей странице URL для клонирования.
В консоли в зависимости от входных данных набираем нечто подобное:

 git clone git@github.com/username/"____".git

После добавления upstream в отслеживаемые, наберите команду git remote -v ещё раз, вы должны увидеть произошедшие изменения.У нас есть основной репозиторий с веткой master и недавно добавленный нами — с upstream. Команда, данная выше, забирает всё новое из ветки upstream и сливает изменения в master.аходясь в только что созданной ветке, вы можете приступить к работе. Вносите в код свои изменения, а когда закончите просто переключитесь обратно к своей основной ветке. Вы можете отправить pull request, выбрав ветку new_branch или же прежде слить изменения из неё в основную ветку разработки. Рассмотрим это подробнее:

$ git checkout master  # вернуться к основной ветке
$ git merge new_branch # слить изменения из new_branch

Если нужно отправить в свой удалённый репозиторий вновь созданную ветку (не сливать её с master), делаем следующее:

$ git push master new_branch

Не торопитесь сливать изменения. Если что-то не заладилось, созданную ветку можно удалить:

$ git branch -d new_branch            # удалить локально
$ git push master :new_branch         # в удалённом репозитории

# ещё один способ удалить ветку в удалённом репозитории
$ git push origin --delete new_branch

Удалить все локальные ветки, которые были смержены (то есть код которых теперь есть) в ветках develop или master:

$ git branch --merged | egrep -v "(master|develop)" | xargs git branch -d


Чтобы сделать pull request, зайдите в свой аккаунт, выбирайте репозиторий владельца и ищите небольшую зелёную кнопку .Перед тем как сделать запрос вы имеете возможность добавить комментарий, просмотреть то, какие файлы будут изменены, какие коммиты добавлены. В верхнем углу окна добавления запроса обратите внимание откуда куда и что вы сливаете. Если необходимо слить основные ветки выбор падёт на репозиторий username:master, если отдельную ветку (вспоминаем branch) — так и указывайте её.А дальше... ждать. Пока придёт владелец оригинального репозитория и примет/отклонит ваши изменения.




